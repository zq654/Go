### **一、LSM 的核心设计思想**

LSM 的设计初衷是**将随机写转化为顺序写，大幅提升写入性能**。传统 B-Tree 存储引擎（如 MySQL InnoDB）在写入时需要随机修改磁盘页，而 LSM 通过以下方式优化：

1. **内存暂存**：新数据先写入内存中的数据结构（MemTable）。
2. **顺序落盘**：MemTable 满后，将数据批量、有序地写入磁盘（生成 SSTable 文件）。
3. **后台合并**：定期合并磁盘上的旧文件，删除过期数据。

### **二、LSM 的核心组件**

#### 1. **MemTable（内存表）**

- **数据结构**：通常使用跳表（SkipList）或红黑树实现，保证插入和查询的时间复杂度为 O (logN)。
- **功能**：暂存**最新写入的数据**，维护有序性，支持快速读写。
- **限制**：内存空间有限，达到阈值（如 64MB）后会触发 flush 操作。

#### 2. **Write-Ahead Log（WAL）**

- **日志文件**：磁盘上的**顺序追加日志，记录所有写入操作**。
- **作用**：防止 MemTable 数据丢失（如崩溃恢复），确保数据持久性。
- **优化**：顺序写性能极高，通常采用同步写入（fsync）或异步刷盘。

#### 3. **SSTable（Sorted String Table）**

- **磁盘文件**：有序键值对存储，支持高效范围查询。
- **分层结构**：通常分为多层（如 Level-0 到 Level-N），每层数据按大小或时间组织。
- **格式**：包含数据块、索引块和布隆过滤器（Bloom Filter），加速查询。

#### 4. **Compaction（合并）**

- **后台任务**：定期合并多个 SSTable 文件，删除过期数据，减少读放大。
- 策略：
  - **大小 - tiered**：按文件大小合并（如 LevelDB 早期版本）。
  - **Leveled**：按层级合并（如 LevelDB、RocksDB），每层数据有序且不重叠。



| **组件**     | **存储位置** | **数据结构**   | **读写特性**         | **核心作用**                 |
| ------------ | ------------ | -------------- | -------------------- | ---------------------------- |
| **MemTable** | 内存         | 跳表、红黑树等 | 随机读写（内存操作） | 暂存最新数据，保证有序性     |
| **WAL**      | 磁盘         | 顺序追加日志   | 顺序写（高性能）     | 持久化记录操作，保障崩溃恢复 |
| **SSTable**  | 磁盘         | 有序键值对文件 | 批量写入、顺序读     | 存储历史数据，支持高效查询   |

### **三、LSM 的读写流程**

#### **写入流程**

1. **记录 WAL**：将写入操作追加到 WAL 日志。
2. **更新 MemTable**：将数据插入内存中的 MemTable（此时数据已可被查询）。
3. **MemTable Flush**：当 MemTable 达到阈值时，将数据有序写入磁盘，生成新的 SSTable 文件（通常为 Level-0）。
4. **WAL 截断**：确认 SSTable 写入成功后，删除旧的 WAL 日志。

#### **读取流程**

1. **查询 MemTable**：先检查内存中的 MemTable 是否存在数据。
2. **查询 Immutable MemTable**：如果 MemTable 正在 flush，检查已冻结的旧 MemTable。
3. **查询 SSTable**：从最新的 SSTable（Level-0）开始，逐层向下查找，直到找到数据或遍历所有层级。
4. **布隆过滤器加速**：使用布隆过滤器快速判断某个键是否存在于 SSTable 中，减少不必要的磁盘 IO。

### **四、Compaction（合并）机制**

#### **为什么需要 Compaction？**

- **减少读放大**：避免查询时需要遍历过多 SSTable 文件。
- **删除过期数据**：合并时删除被覆盖或删除的数据（如墓碑标记 Tombstone）。
- **空间优化**：合并小文件为大文件，减少磁盘碎片。

#### **两种主要 Compaction 策略**

1. **Minor Compaction**
   - **触发条件**：MemTable Flush 时。
   - **操作**：将 Level-0 的 SSTable 与下层合并，生成新的 Level-1 文件。
   - **特点**：快速，但可能产生临时冗余数据。
2. **Major Compaction**
   - **触发条件**：定期或手动触发。
   - **操作**：合并多层 SSTable，生成最终的有序大文件。
   - **特点**：耗时，但能彻底清理冗余数据，优化读写性能。

### **五、LSM 的优缺点**

#### **优点**

1. **极高的写入性能**：顺序写磁盘远快于 B-Tree 的随机写。
2. **简单的崩溃恢复**：通过 WAL 快速重建 MemTable。
3. **高效的批量操作**：适合大数据量的导入和导出。
4. **天然支持范围查询**：SSTable 的有序性保证了高效的区间扫描。

#### **缺点**

1. **读放大（Read Amplification）**：查询可能需要访问多个 SSTable 文件。
2. **写放大（Write Amplification）**：Compaction 会导致重复写入，增加磁盘 IO。
3. **空间放大（Space Amplification）**：数据冗余（如未合并的旧版本）占用更多空间。
4. **Compaction 风暴**：大量 Compaction 可能导致系统性能波动。

### **六、LSM 与 B-Tree 的对比**

| **特性**       | **LSM Tree**                 | **B-Tree**                   |
| -------------- | ---------------------------- | ---------------------------- |
| **写入性能**   | 高（顺序写）                 | 低（随机写）                 |
| **读取性能**   | 低（读放大）                 | 高（随机读）                 |
| **空间利用率** | 低（空间放大）               | 高（无冗余）                 |
| **适用场景**   | 写多读少（如日志、时序数据） | 读多写少（如关系型数据库）   |
| **典型实现**   | LevelDB、RocksDB、Cassandra  | MySQL InnoDB、B + 树文件系统 |

### **七、LSM 的优化技术**

1. **布隆过滤器（Bloom Filter）**：快速判断键是否存在于 SSTable 中，减少磁盘 IO。
2. **前缀压缩（Prefix Compression）**：相邻键的公共前缀只存储一次，节省空间。
3. **块缓存（Block Cache）**：缓存频繁访问的 SSTable 数据块，提升读取性能。
4. **分层设计**：不同层级采用不同的 Compaction 策略（如 LevelDB 的 Leveled Compaction）。
5. **并发优化**：允许多个 MemTable 和 Compaction 任务并行执行。
