# **Raft核心思路**

## 首先需要清楚整个Raft的流程：

1. 首先每个节点都是从follower开始，需设计一个随机定时器，当定时器时间内没有收到心跳就转化身份为candidate并开始选举。
2. 在任何时期只要发现其他节点的任期大于自身的时候，就要修改自身任期已经修改身份为follower（若在选举，则停止选取，若为leader则停止心跳 并降为follower）。
3. 开始选举的时候需要先给自己投一票并将当前任期加一，然后向其他节点申请投票，当获取的选票大于一半则当选为新leader。
4. 被请求投票节点在请求投票时需要比较两者之间任期的大小，并且记录一个VoteFor表示这个任期内投票给了谁。
5. 当节点当选为leader后需要向其它节点发送心跳（传递自己任期）来确保自身的领导地位，若是刚刚当选还需要向其他节点同步日志。
6. 当leader接收到客户端的请求后，需要将日志同步发给其他节点，只有被大多数节点都接收了之后才能提交并应用于状态机，且leader只能提交当前任期的日志。

## 其次要梳理Raft的关键设计：

Q：如何设计一个只要接收到信号就要重置选举时间的定时器（只能用time.sleep）

A：用一个channel接收心跳 ，每收到一个心跳就写到channel里面，一个协程读channel ，当读到数据就给



Q：对于Term是会有非常多地方对term做改变，例如 F是否投票， C获取投票，任一节点接收到大于自己term的消息时都会改变Term

A：我的解决方法是只有可能涉及更改term之前要读一下的时候会上锁，其他时候我都采用atomic操作

eg：当定时器到期了之接atomic.add

eg:  当选票对比时先**不要** lock 通过atomic.load数据 **如果C发送过来的大再lock住** 比较要不要更改atomic.store然后unlock

eg：当选举过程中发现有大于自己任期的心跳，或者返回的任期大于自己时，要先load出来比较一下，当接收的比较大，再lock住决定要不要更改term。在请求投票过程中每发一个请求之前都确认一下自己是不是C，如果不是则退出。在开始投票时先将C的term load出来为一个常量 ，当收到返回的term大于自己的时候 lock然后比较任期并更改。

​	condiser：有了先不上锁初步比较再决定要不要上锁可以解决 当C1给C2发请求 同时C2给C1发请求时的死锁问题